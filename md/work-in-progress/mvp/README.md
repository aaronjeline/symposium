# "Minimum Viable Demo"

This is our initial demo, meant to convey the *concept* of taskspaces and the overall Symposium workflow.

 ## Key workflows

### Installation

In this initial version, installation works like:

* User checks out the Symposium repository and runs `cargo setup`
    * This builds and installs the VSCode Extension.
    * This builds the MCP server and configures it to work with Claude Code or Q CLI at the user level.
    * This builds the Symposium App.
    
### Granting permissions on app startup

* If App does not have acessibility permissions, apps open settings dialog that guides user to grant permissions
    * Dialog also checks for Screen Recording permissions, but these are optional

### Selecting a project

* The user will be prompted to open an existing project or a create a new one
* Projects are represented as directories with a name like `my-project.symposium`. Each contains:
    * a `project.json` file with metadata:
        * Git URL for the project
    * subdirectories with names like `task-$UUID` that contain
        * a clone of the project, named after the repo (e.g., `symposium`)
        * a `taskspace.json` with other metadata about the project
            * Name
            * Description
            * Logs
            * a State which can be
                * `Hatchling { initial_prompt: String }` -- a taskspace that hasn't started yet
                * `Resume` -- an active task space whose agent should resume from where it left off

### Opening a project

When the project is opened, it will display a window depicting each active taskspace:

```                                                        
 ┌─────────────────────────────────────────────────────┐ 
 │ ┌────────┐  ┌───────┐  ┌───┬───┐  ┌───┬───┐         │ 
 │ │        │  │       │  │   │   │  │   │   │         │ 
 │ │ Logo   │  ┼───────┼  │   │   │  ┼───┴───┼ ...     │ 
 │ │        │  │       │  │   │   │  │       │         │ 
 │ └────────┘  └───────┘  └───┴───┘  └───────┘         │ 
 │                                                     │ 
 │  ────────────────────────────────────────────────   │ 
 │                                                     │ 
 │ ┌──────────────────────┐                            │ 
 │ │                      │ *Agent space name*         │ 
 │ │ ┌───────┐   ┌────┐   │                            │ 
 │ │ │       │   │    │   │ * Log 1                    │ 
 │ │ │       │   │    │   │ * Log 2                    │ 
 │ │ │       │   └────┘   │ * ..                       │ 
 │ │ │       │            │ * Log N                    │ 
 │ │ │       │ ┌────────┐ │                            │ 
 │ │ └───────┘ │        │ │                            │ 
 │ │           │        │ │                            │ 
 │ │           └────────┘ │                            │ 
 │ └──────────────────────┘                            │ 
 │                                                     │ 
 │  ─────────────────────────────────────────────────  │ 
 │                                                     │ 
 │ ┌──────────────────────┐                            │ 
 │ │                      │ *Another agent space*      │ 
 │ │ ┌──────────────────┐ │                            │ 
 │ │ │                  │ │ * Log 1                    │ 
 │ │ │                  │ │ * ...                      │ 
 │ │ │                  │ │                            │ 
 │ │ │                  │ │                            │ 
 │ │ └──────────────────┘ │                            │ 
 │ │ ┌──────────────────┐ │                            │ 
 │ │ │                  │ │                            │ 
 │ │ └──────────────────┘ │                            │ 
 │ └──────────────────────┘                            │ 
 │                                                     │ 
 └─────────────────────────────────────────────────────┘ 
                                                         
```

The panel is divided into sections with:

* The top section showing various tiling configurations
    * Clicking these buttons will position the windows in the shown configuration, maximizing them over the display but with space left for the panel
    * When they are tiled in this way, we monitor for resize events
    * When windows are resized, we resize the others to match
    * If windows are moved they return to "free form mode" where their position is not actively monitored by the app
* The other sections representing active taskspaces, with the current taskspace at the top
* Each taskspace contains
    * Periodic screenshots of the windows associated with the Taskspace, positioned in the same way relative to the overall display
    * The name of the taskspace  
    * A display of logs generated by the agent via `log_progress` MCP tool calls, showing progress messages with visual indicators
* When agents use `signal_user` to request assistance, their taskspace is automatically ordered closer to the front of the panel

### Starting a new taskspace

There are two ways to create taskspaces:

**Manual creation via UI:**
* When the user clicks "New Taskspace", we create a taskspace with default values:
    * Name: "Unnamed taskspace"
    * Description: "TBD" 
    * Initial prompt: "This is a newly created taskspace. Figure out what the user wants to do and update the name/description appropriately using the `update_taskspace` tool."
* The AI agent will use the `update_taskspace` MCP tool to set appropriate name/description based on user interaction

**Programmatic creation via MCP:**
* When an AI agent uses the `spawn_taskspace` MCP tool, it provides a specific name, description, and initial prompt
* This allows agents to create focused taskspaces for specific tasks

**Common flow for both:**
* To start a new taskspace, we assign it a UUID and create a directory
* We then clone the given git url into that directory
* We create initial metadata, setting the state to Hatchling.
* We then proceed to "open" it as if it were an existing taskspace

### Starting existing taskspaces

* When a project is opened, we open VSCode sessions for all existing taskspaces.
* The VSCode extension will detect that it is running in taskspace and check the `taskspace.json` file in the parent directory of where it was started.
    * The extension creates a new Terminal and launches the configured agent (Q CLI or Claude Code).
    * If the state is Hatchling, the extension it will start up the agent with that initial prompt. The json will then be rewritten to have the state of "Resume".
* The VSCode's window ID is recorded and associated with that taskspace.

### Receiving updates

* The Symposium app will connect to the daemon and monitor for updates. It will react to messages sent by the following MCP tools. It is able to identify the taskspace by looking at the PID in the message, which will include the PID of the VSCode window.
    * `spawn_taskspace`, starts a new taskspace
    * `update_taskspace`, updates the name and description of the current taskspace
    * `log_progress`, adds the log to the taskspace metadata, saves the `taskspace.json` file, and updates the display
    * `signal_user`, adds the log to the taskspace metdata and adds a badge to the dock icon.

### Selecting a taskspace

* When the user clicks in the GUI on one of the taskspaces, we bring its associated windows to the front (at present, this is only one, the VSCode IDE).

This clears any pending signals, updating the dock icon for the app.

